// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MIA_MIA_H_
#define FLATBUFFERS_GENERATED_MIA_MIA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace Mia {

struct GPIOCommand;
struct GPIOCommandBuilder;

struct GPIOResponse;
struct GPIOResponseBuilder;

struct SensorTelemetry;
struct SensorTelemetryBuilder;

struct SystemStatus;
struct SystemStatusBuilder;

struct CommandAck;
struct CommandAckBuilder;

struct DeviceInfo;
struct DeviceInfoBuilder;

struct LEDState;
struct LEDStateBuilder;

struct VehicleTelemetry;
struct VehicleTelemetryBuilder;

enum class GPIODirection : int8_t {
  Input = 0,
  Output = 1,
  PWM = 2,
  MIN = Input,
  MAX = PWM
};

inline const GPIODirection (&EnumValuesGPIODirection())[3] {
  static const GPIODirection values[] = {
    GPIODirection::Input,
    GPIODirection::Output,
    GPIODirection::PWM
  };
  return values;
}

inline const char * const *EnumNamesGPIODirection() {
  static const char * const names[4] = {
    "Input",
    "Output",
    "PWM",
    nullptr
  };
  return names;
}

inline const char *EnumNameGPIODirection(GPIODirection e) {
  if (::flatbuffers::IsOutRange(e, GPIODirection::Input, GPIODirection::PWM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGPIODirection()[index];
}

enum class SensorType : int8_t {
  Temperature = 0,
  Humidity = 1,
  Distance = 2,
  Pressure = 3,
  Light = 4,
  Motion = 5,
  MIN = Temperature,
  MAX = Motion
};

inline const SensorType (&EnumValuesSensorType())[6] {
  static const SensorType values[] = {
    SensorType::Temperature,
    SensorType::Humidity,
    SensorType::Distance,
    SensorType::Pressure,
    SensorType::Light,
    SensorType::Motion
  };
  return values;
}

inline const char * const *EnumNamesSensorType() {
  static const char * const names[7] = {
    "Temperature",
    "Humidity",
    "Distance",
    "Pressure",
    "Light",
    "Motion",
    nullptr
  };
  return names;
}

inline const char *EnumNameSensorType(SensorType e) {
  if (::flatbuffers::IsOutRange(e, SensorType::Temperature, SensorType::Motion)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSensorType()[index];
}

enum class CommandStatus : int8_t {
  Success = 0,
  Failure = 1,
  Timeout = 2,
  Invalid = 3,
  MIN = Success,
  MAX = Invalid
};

inline const CommandStatus (&EnumValuesCommandStatus())[4] {
  static const CommandStatus values[] = {
    CommandStatus::Success,
    CommandStatus::Failure,
    CommandStatus::Timeout,
    CommandStatus::Invalid
  };
  return values;
}

inline const char * const *EnumNamesCommandStatus() {
  static const char * const names[5] = {
    "Success",
    "Failure",
    "Timeout",
    "Invalid",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommandStatus(CommandStatus e) {
  if (::flatbuffers::IsOutRange(e, CommandStatus::Success, CommandStatus::Invalid)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCommandStatus()[index];
}

enum class DeviceType : int8_t {
  GPIO = 0,
  Sensor = 1,
  Actuator = 2,
  Display = 3,
  Network = 4,
  MIN = GPIO,
  MAX = Network
};

inline const DeviceType (&EnumValuesDeviceType())[5] {
  static const DeviceType values[] = {
    DeviceType::GPIO,
    DeviceType::Sensor,
    DeviceType::Actuator,
    DeviceType::Display,
    DeviceType::Network
  };
  return values;
}

inline const char * const *EnumNamesDeviceType() {
  static const char * const names[6] = {
    "GPIO",
    "Sensor",
    "Actuator",
    "Display",
    "Network",
    nullptr
  };
  return names;
}

inline const char *EnumNameDeviceType(DeviceType e) {
  if (::flatbuffers::IsOutRange(e, DeviceType::GPIO, DeviceType::Network)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDeviceType()[index];
}

enum class LEDMode : int8_t {
  Drive = 0,
  Parked = 1,
  Night = 2,
  Service = 3,
  Emergency = 4,
  MIN = Drive,
  MAX = Emergency
};

inline const LEDMode (&EnumValuesLEDMode())[5] {
  static const LEDMode values[] = {
    LEDMode::Drive,
    LEDMode::Parked,
    LEDMode::Night,
    LEDMode::Service,
    LEDMode::Emergency
  };
  return values;
}

inline const char * const *EnumNamesLEDMode() {
  static const char * const names[6] = {
    "Drive",
    "Parked",
    "Night",
    "Service",
    "Emergency",
    nullptr
  };
  return names;
}

inline const char *EnumNameLEDMode(LEDMode e) {
  if (::flatbuffers::IsOutRange(e, LEDMode::Drive, LEDMode::Emergency)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLEDMode()[index];
}

enum class AIState : int8_t {
  Listening = 0,
  Speaking = 1,
  Thinking = 2,
  Recording = 3,
  Error = 4,
  Idle = 5,
  MIN = Listening,
  MAX = Idle
};

inline const AIState (&EnumValuesAIState())[6] {
  static const AIState values[] = {
    AIState::Listening,
    AIState::Speaking,
    AIState::Thinking,
    AIState::Recording,
    AIState::Error,
    AIState::Idle
  };
  return values;
}

inline const char * const *EnumNamesAIState() {
  static const char * const names[7] = {
    "Listening",
    "Speaking",
    "Thinking",
    "Recording",
    "Error",
    "Idle",
    nullptr
  };
  return names;
}

inline const char *EnumNameAIState(AIState e) {
  if (::flatbuffers::IsOutRange(e, AIState::Listening, AIState::Idle)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAIState()[index];
}

enum class DpfStatus : int8_t {
  Normal = 0,
  Regenerating = 1,
  Warning = 2,
  Critical = 3,
  MIN = Normal,
  MAX = Critical
};

inline const DpfStatus (&EnumValuesDpfStatus())[4] {
  static const DpfStatus values[] = {
    DpfStatus::Normal,
    DpfStatus::Regenerating,
    DpfStatus::Warning,
    DpfStatus::Critical
  };
  return values;
}

inline const char * const *EnumNamesDpfStatus() {
  static const char * const names[5] = {
    "Normal",
    "Regenerating",
    "Warning",
    "Critical",
    nullptr
  };
  return names;
}

inline const char *EnumNameDpfStatus(DpfStatus e) {
  if (::flatbuffers::IsOutRange(e, DpfStatus::Normal, DpfStatus::Critical)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDpfStatus()[index];
}

struct GPIOCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GPIOCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PIN = 4,
    VT_DIRECTION = 6,
    VT_VALUE = 8,
    VT_TIMESTAMP = 10
  };
  int32_t pin() const {
    return GetField<int32_t>(VT_PIN, 0);
  }
  bool mutate_pin(int32_t _pin = 0) {
    return SetField<int32_t>(VT_PIN, _pin, 0);
  }
  Mia::GPIODirection direction() const {
    return static_cast<Mia::GPIODirection>(GetField<int8_t>(VT_DIRECTION, 0));
  }
  bool mutate_direction(Mia::GPIODirection _direction = static_cast<Mia::GPIODirection>(0)) {
    return SetField<int8_t>(VT_DIRECTION, static_cast<int8_t>(_direction), 0);
  }
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool mutate_value(bool _value = 0) {
    return SetField<uint8_t>(VT_VALUE, static_cast<uint8_t>(_value), 0);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(uint64_t _timestamp = 0) {
    return SetField<uint64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PIN, 4) &&
           VerifyField<int8_t>(verifier, VT_DIRECTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct GPIOCommandBuilder {
  typedef GPIOCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pin(int32_t pin) {
    fbb_.AddElement<int32_t>(GPIOCommand::VT_PIN, pin, 0);
  }
  void add_direction(Mia::GPIODirection direction) {
    fbb_.AddElement<int8_t>(GPIOCommand::VT_DIRECTION, static_cast<int8_t>(direction), 0);
  }
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(GPIOCommand::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(GPIOCommand::VT_TIMESTAMP, timestamp, 0);
  }
  explicit GPIOCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GPIOCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GPIOCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GPIOCommand> CreateGPIOCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pin = 0,
    Mia::GPIODirection direction = Mia::GPIODirection::Input,
    bool value = false,
    uint64_t timestamp = 0) {
  GPIOCommandBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_pin(pin);
  builder_.add_value(value);
  builder_.add_direction(direction);
  return builder_.Finish();
}

struct GPIOResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GPIOResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PIN = 4,
    VT_SUCCESS = 6,
    VT_VALUE = 8,
    VT_ERROR_MESSAGE = 10,
    VT_TIMESTAMP = 12
  };
  int32_t pin() const {
    return GetField<int32_t>(VT_PIN, 0);
  }
  bool mutate_pin(int32_t _pin = 0) {
    return SetField<int32_t>(VT_PIN, _pin, 0);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool mutate_success(bool _success = 0) {
    return SetField<uint8_t>(VT_SUCCESS, static_cast<uint8_t>(_success), 0);
  }
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool mutate_value(bool _value = 0) {
    return SetField<uint8_t>(VT_VALUE, static_cast<uint8_t>(_value), 0);
  }
  const ::flatbuffers::String *error_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  ::flatbuffers::String *mutable_error_message() {
    return GetPointer<::flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(uint64_t _timestamp = 0) {
    return SetField<uint64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PIN, 4) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct GPIOResponseBuilder {
  typedef GPIOResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pin(int32_t pin) {
    fbb_.AddElement<int32_t>(GPIOResponse::VT_PIN, pin, 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(GPIOResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(GPIOResponse::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  void add_error_message(::flatbuffers::Offset<::flatbuffers::String> error_message) {
    fbb_.AddOffset(GPIOResponse::VT_ERROR_MESSAGE, error_message);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(GPIOResponse::VT_TIMESTAMP, timestamp, 0);
  }
  explicit GPIOResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GPIOResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GPIOResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GPIOResponse> CreateGPIOResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pin = 0,
    bool success = false,
    bool value = false,
    ::flatbuffers::Offset<::flatbuffers::String> error_message = 0,
    uint64_t timestamp = 0) {
  GPIOResponseBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_error_message(error_message);
  builder_.add_pin(pin);
  builder_.add_value(value);
  builder_.add_success(success);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GPIOResponse> CreateGPIOResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pin = 0,
    bool success = false,
    bool value = false,
    const char *error_message = nullptr,
    uint64_t timestamp = 0) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return Mia::CreateGPIOResponse(
      _fbb,
      pin,
      success,
      value,
      error_message__,
      timestamp);
}

struct SensorTelemetry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SensorTelemetryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SENSOR_ID = 4,
    VT_SENSOR_TYPE = 6,
    VT_VALUE = 8,
    VT_UNIT = 10,
    VT_TIMESTAMP = 12,
    VT_METADATA = 14
  };
  const ::flatbuffers::String *sensor_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SENSOR_ID);
  }
  ::flatbuffers::String *mutable_sensor_id() {
    return GetPointer<::flatbuffers::String *>(VT_SENSOR_ID);
  }
  Mia::SensorType sensor_type() const {
    return static_cast<Mia::SensorType>(GetField<int8_t>(VT_SENSOR_TYPE, 0));
  }
  bool mutate_sensor_type(Mia::SensorType _sensor_type = static_cast<Mia::SensorType>(0)) {
    return SetField<int8_t>(VT_SENSOR_TYPE, static_cast<int8_t>(_sensor_type), 0);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool mutate_value(float _value = 0.0f) {
    return SetField<float>(VT_VALUE, _value, 0.0f);
  }
  const ::flatbuffers::String *unit() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UNIT);
  }
  ::flatbuffers::String *mutable_unit() {
    return GetPointer<::flatbuffers::String *>(VT_UNIT);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(uint64_t _timestamp = 0) {
    return SetField<uint64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *metadata() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_METADATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_metadata() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SENSOR_ID) &&
           verifier.VerifyString(sensor_id()) &&
           VerifyField<int8_t>(verifier, VT_SENSOR_TYPE, 1) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           VerifyOffset(verifier, VT_UNIT) &&
           verifier.VerifyString(unit()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyVector(metadata()) &&
           verifier.EndTable();
  }
};

struct SensorTelemetryBuilder {
  typedef SensorTelemetry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sensor_id(::flatbuffers::Offset<::flatbuffers::String> sensor_id) {
    fbb_.AddOffset(SensorTelemetry::VT_SENSOR_ID, sensor_id);
  }
  void add_sensor_type(Mia::SensorType sensor_type) {
    fbb_.AddElement<int8_t>(SensorTelemetry::VT_SENSOR_TYPE, static_cast<int8_t>(sensor_type), 0);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(SensorTelemetry::VT_VALUE, value, 0.0f);
  }
  void add_unit(::flatbuffers::Offset<::flatbuffers::String> unit) {
    fbb_.AddOffset(SensorTelemetry::VT_UNIT, unit);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(SensorTelemetry::VT_TIMESTAMP, timestamp, 0);
  }
  void add_metadata(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> metadata) {
    fbb_.AddOffset(SensorTelemetry::VT_METADATA, metadata);
  }
  explicit SensorTelemetryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SensorTelemetry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SensorTelemetry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SensorTelemetry> CreateSensorTelemetry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> sensor_id = 0,
    Mia::SensorType sensor_type = Mia::SensorType::Temperature,
    float value = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> unit = 0,
    uint64_t timestamp = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> metadata = 0) {
  SensorTelemetryBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_metadata(metadata);
  builder_.add_unit(unit);
  builder_.add_value(value);
  builder_.add_sensor_id(sensor_id);
  builder_.add_sensor_type(sensor_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SensorTelemetry> CreateSensorTelemetryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *sensor_id = nullptr,
    Mia::SensorType sensor_type = Mia::SensorType::Temperature,
    float value = 0.0f,
    const char *unit = nullptr,
    uint64_t timestamp = 0,
    const std::vector<uint8_t> *metadata = nullptr) {
  auto sensor_id__ = sensor_id ? _fbb.CreateString(sensor_id) : 0;
  auto unit__ = unit ? _fbb.CreateString(unit) : 0;
  auto metadata__ = metadata ? _fbb.CreateVector<uint8_t>(*metadata) : 0;
  return Mia::CreateSensorTelemetry(
      _fbb,
      sensor_id__,
      sensor_type,
      value,
      unit__,
      timestamp,
      metadata__);
}

struct SystemStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SystemStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPTIME_SECONDS = 4,
    VT_MEMORY_PERCENT = 6,
    VT_CPU_PERCENT = 8,
    VT_DEVICE_COUNT = 10,
    VT_TIMESTAMP = 12
  };
  uint64_t uptime_seconds() const {
    return GetField<uint64_t>(VT_UPTIME_SECONDS, 0);
  }
  bool mutate_uptime_seconds(uint64_t _uptime_seconds = 0) {
    return SetField<uint64_t>(VT_UPTIME_SECONDS, _uptime_seconds, 0);
  }
  float memory_percent() const {
    return GetField<float>(VT_MEMORY_PERCENT, 0.0f);
  }
  bool mutate_memory_percent(float _memory_percent = 0.0f) {
    return SetField<float>(VT_MEMORY_PERCENT, _memory_percent, 0.0f);
  }
  float cpu_percent() const {
    return GetField<float>(VT_CPU_PERCENT, 0.0f);
  }
  bool mutate_cpu_percent(float _cpu_percent = 0.0f) {
    return SetField<float>(VT_CPU_PERCENT, _cpu_percent, 0.0f);
  }
  int32_t device_count() const {
    return GetField<int32_t>(VT_DEVICE_COUNT, 0);
  }
  bool mutate_device_count(int32_t _device_count = 0) {
    return SetField<int32_t>(VT_DEVICE_COUNT, _device_count, 0);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(uint64_t _timestamp = 0) {
    return SetField<uint64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_UPTIME_SECONDS, 8) &&
           VerifyField<float>(verifier, VT_MEMORY_PERCENT, 4) &&
           VerifyField<float>(verifier, VT_CPU_PERCENT, 4) &&
           VerifyField<int32_t>(verifier, VT_DEVICE_COUNT, 4) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct SystemStatusBuilder {
  typedef SystemStatus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uptime_seconds(uint64_t uptime_seconds) {
    fbb_.AddElement<uint64_t>(SystemStatus::VT_UPTIME_SECONDS, uptime_seconds, 0);
  }
  void add_memory_percent(float memory_percent) {
    fbb_.AddElement<float>(SystemStatus::VT_MEMORY_PERCENT, memory_percent, 0.0f);
  }
  void add_cpu_percent(float cpu_percent) {
    fbb_.AddElement<float>(SystemStatus::VT_CPU_PERCENT, cpu_percent, 0.0f);
  }
  void add_device_count(int32_t device_count) {
    fbb_.AddElement<int32_t>(SystemStatus::VT_DEVICE_COUNT, device_count, 0);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(SystemStatus::VT_TIMESTAMP, timestamp, 0);
  }
  explicit SystemStatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SystemStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SystemStatus>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SystemStatus> CreateSystemStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t uptime_seconds = 0,
    float memory_percent = 0.0f,
    float cpu_percent = 0.0f,
    int32_t device_count = 0,
    uint64_t timestamp = 0) {
  SystemStatusBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_uptime_seconds(uptime_seconds);
  builder_.add_device_count(device_count);
  builder_.add_cpu_percent(cpu_percent);
  builder_.add_memory_percent(memory_percent);
  return builder_.Finish();
}

struct CommandAck FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandAckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND_ID = 4,
    VT_STATUS = 6,
    VT_ERROR_MESSAGE = 8,
    VT_RESPONSE_DATA = 10,
    VT_TIMESTAMP = 12
  };
  const ::flatbuffers::String *command_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMAND_ID);
  }
  ::flatbuffers::String *mutable_command_id() {
    return GetPointer<::flatbuffers::String *>(VT_COMMAND_ID);
  }
  Mia::CommandStatus status() const {
    return static_cast<Mia::CommandStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  bool mutate_status(Mia::CommandStatus _status = static_cast<Mia::CommandStatus>(0)) {
    return SetField<int8_t>(VT_STATUS, static_cast<int8_t>(_status), 0);
  }
  const ::flatbuffers::String *error_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  ::flatbuffers::String *mutable_error_message() {
    return GetPointer<::flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  const ::flatbuffers::Vector<uint8_t> *response_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RESPONSE_DATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_response_data() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_RESPONSE_DATA);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(uint64_t _timestamp = 0) {
    return SetField<uint64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMAND_ID) &&
           verifier.VerifyString(command_id()) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           VerifyOffset(verifier, VT_RESPONSE_DATA) &&
           verifier.VerifyVector(response_data()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct CommandAckBuilder {
  typedef CommandAck Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_command_id(::flatbuffers::Offset<::flatbuffers::String> command_id) {
    fbb_.AddOffset(CommandAck::VT_COMMAND_ID, command_id);
  }
  void add_status(Mia::CommandStatus status) {
    fbb_.AddElement<int8_t>(CommandAck::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_error_message(::flatbuffers::Offset<::flatbuffers::String> error_message) {
    fbb_.AddOffset(CommandAck::VT_ERROR_MESSAGE, error_message);
  }
  void add_response_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> response_data) {
    fbb_.AddOffset(CommandAck::VT_RESPONSE_DATA, response_data);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(CommandAck::VT_TIMESTAMP, timestamp, 0);
  }
  explicit CommandAckBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CommandAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CommandAck>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CommandAck> CreateCommandAck(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> command_id = 0,
    Mia::CommandStatus status = Mia::CommandStatus::Success,
    ::flatbuffers::Offset<::flatbuffers::String> error_message = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> response_data = 0,
    uint64_t timestamp = 0) {
  CommandAckBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_response_data(response_data);
  builder_.add_error_message(error_message);
  builder_.add_command_id(command_id);
  builder_.add_status(status);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CommandAck> CreateCommandAckDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *command_id = nullptr,
    Mia::CommandStatus status = Mia::CommandStatus::Success,
    const char *error_message = nullptr,
    const std::vector<uint8_t> *response_data = nullptr,
    uint64_t timestamp = 0) {
  auto command_id__ = command_id ? _fbb.CreateString(command_id) : 0;
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  auto response_data__ = response_data ? _fbb.CreateVector<uint8_t>(*response_data) : 0;
  return Mia::CreateCommandAck(
      _fbb,
      command_id__,
      status,
      error_message__,
      response_data__,
      timestamp);
}

struct DeviceInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeviceInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEVICE_ID = 4,
    VT_DEVICE_TYPE = 6,
    VT_NAME = 8,
    VT_CAPABILITIES = 10,
    VT_STATUS = 12,
    VT_LAST_SEEN = 14,
    VT_METADATA = 16
  };
  const ::flatbuffers::String *device_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEVICE_ID);
  }
  ::flatbuffers::String *mutable_device_id() {
    return GetPointer<::flatbuffers::String *>(VT_DEVICE_ID);
  }
  Mia::DeviceType device_type() const {
    return static_cast<Mia::DeviceType>(GetField<int8_t>(VT_DEVICE_TYPE, 0));
  }
  bool mutate_device_type(Mia::DeviceType _device_type = static_cast<Mia::DeviceType>(0)) {
    return SetField<int8_t>(VT_DEVICE_TYPE, static_cast<int8_t>(_device_type), 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *capabilities() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CAPABILITIES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_capabilities() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CAPABILITIES);
  }
  const ::flatbuffers::String *status() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS);
  }
  ::flatbuffers::String *mutable_status() {
    return GetPointer<::flatbuffers::String *>(VT_STATUS);
  }
  uint64_t last_seen() const {
    return GetField<uint64_t>(VT_LAST_SEEN, 0);
  }
  bool mutate_last_seen(uint64_t _last_seen = 0) {
    return SetField<uint64_t>(VT_LAST_SEEN, _last_seen, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *metadata() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_METADATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_metadata() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICE_ID) &&
           verifier.VerifyString(device_id()) &&
           VerifyField<int8_t>(verifier, VT_DEVICE_TYPE, 1) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_CAPABILITIES) &&
           verifier.VerifyVector(capabilities()) &&
           verifier.VerifyVectorOfStrings(capabilities()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           VerifyField<uint64_t>(verifier, VT_LAST_SEEN, 8) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyVector(metadata()) &&
           verifier.EndTable();
  }
};

struct DeviceInfoBuilder {
  typedef DeviceInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_device_id(::flatbuffers::Offset<::flatbuffers::String> device_id) {
    fbb_.AddOffset(DeviceInfo::VT_DEVICE_ID, device_id);
  }
  void add_device_type(Mia::DeviceType device_type) {
    fbb_.AddElement<int8_t>(DeviceInfo::VT_DEVICE_TYPE, static_cast<int8_t>(device_type), 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(DeviceInfo::VT_NAME, name);
  }
  void add_capabilities(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> capabilities) {
    fbb_.AddOffset(DeviceInfo::VT_CAPABILITIES, capabilities);
  }
  void add_status(::flatbuffers::Offset<::flatbuffers::String> status) {
    fbb_.AddOffset(DeviceInfo::VT_STATUS, status);
  }
  void add_last_seen(uint64_t last_seen) {
    fbb_.AddElement<uint64_t>(DeviceInfo::VT_LAST_SEEN, last_seen, 0);
  }
  void add_metadata(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> metadata) {
    fbb_.AddOffset(DeviceInfo::VT_METADATA, metadata);
  }
  explicit DeviceInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeviceInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeviceInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeviceInfo> CreateDeviceInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> device_id = 0,
    Mia::DeviceType device_type = Mia::DeviceType::GPIO,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> capabilities = 0,
    ::flatbuffers::Offset<::flatbuffers::String> status = 0,
    uint64_t last_seen = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> metadata = 0) {
  DeviceInfoBuilder builder_(_fbb);
  builder_.add_last_seen(last_seen);
  builder_.add_metadata(metadata);
  builder_.add_status(status);
  builder_.add_capabilities(capabilities);
  builder_.add_name(name);
  builder_.add_device_id(device_id);
  builder_.add_device_type(device_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DeviceInfo> CreateDeviceInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *device_id = nullptr,
    Mia::DeviceType device_type = Mia::DeviceType::GPIO,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *capabilities = nullptr,
    const char *status = nullptr,
    uint64_t last_seen = 0,
    const std::vector<uint8_t> *metadata = nullptr) {
  auto device_id__ = device_id ? _fbb.CreateString(device_id) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto capabilities__ = capabilities ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*capabilities) : 0;
  auto status__ = status ? _fbb.CreateString(status) : 0;
  auto metadata__ = metadata ? _fbb.CreateVector<uint8_t>(*metadata) : 0;
  return Mia::CreateDeviceInfo(
      _fbb,
      device_id__,
      device_type,
      name__,
      capabilities__,
      status__,
      last_seen,
      metadata__);
}

struct LEDState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LEDStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_AI_STATE = 6,
    VT_BRIGHTNESS = 8,
    VT_SERVICE_STATUS = 10,
    VT_OBD_DATA = 12,
    VT_TIMESTAMP = 14
  };
  Mia::LEDMode mode() const {
    return static_cast<Mia::LEDMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool mutate_mode(Mia::LEDMode _mode = static_cast<Mia::LEDMode>(0)) {
    return SetField<int8_t>(VT_MODE, static_cast<int8_t>(_mode), 0);
  }
  Mia::AIState ai_state() const {
    return static_cast<Mia::AIState>(GetField<int8_t>(VT_AI_STATE, 0));
  }
  bool mutate_ai_state(Mia::AIState _ai_state = static_cast<Mia::AIState>(0)) {
    return SetField<int8_t>(VT_AI_STATE, static_cast<int8_t>(_ai_state), 0);
  }
  float brightness() const {
    return GetField<float>(VT_BRIGHTNESS, 0.0f);
  }
  bool mutate_brightness(float _brightness = 0.0f) {
    return SetField<float>(VT_BRIGHTNESS, _brightness, 0.0f);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *service_status() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SERVICE_STATUS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_service_status() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SERVICE_STATUS);
  }
  const ::flatbuffers::Vector<uint8_t> *obd_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OBD_DATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_obd_data() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_OBD_DATA);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(uint64_t _timestamp = 0) {
    return SetField<uint64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE, 1) &&
           VerifyField<int8_t>(verifier, VT_AI_STATE, 1) &&
           VerifyField<float>(verifier, VT_BRIGHTNESS, 4) &&
           VerifyOffset(verifier, VT_SERVICE_STATUS) &&
           verifier.VerifyVector(service_status()) &&
           verifier.VerifyVectorOfStrings(service_status()) &&
           VerifyOffset(verifier, VT_OBD_DATA) &&
           verifier.VerifyVector(obd_data()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct LEDStateBuilder {
  typedef LEDState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mode(Mia::LEDMode mode) {
    fbb_.AddElement<int8_t>(LEDState::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_ai_state(Mia::AIState ai_state) {
    fbb_.AddElement<int8_t>(LEDState::VT_AI_STATE, static_cast<int8_t>(ai_state), 0);
  }
  void add_brightness(float brightness) {
    fbb_.AddElement<float>(LEDState::VT_BRIGHTNESS, brightness, 0.0f);
  }
  void add_service_status(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> service_status) {
    fbb_.AddOffset(LEDState::VT_SERVICE_STATUS, service_status);
  }
  void add_obd_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> obd_data) {
    fbb_.AddOffset(LEDState::VT_OBD_DATA, obd_data);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(LEDState::VT_TIMESTAMP, timestamp, 0);
  }
  explicit LEDStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LEDState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LEDState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LEDState> CreateLEDState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Mia::LEDMode mode = Mia::LEDMode::Drive,
    Mia::AIState ai_state = Mia::AIState::Listening,
    float brightness = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> service_status = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> obd_data = 0,
    uint64_t timestamp = 0) {
  LEDStateBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_obd_data(obd_data);
  builder_.add_service_status(service_status);
  builder_.add_brightness(brightness);
  builder_.add_ai_state(ai_state);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LEDState> CreateLEDStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Mia::LEDMode mode = Mia::LEDMode::Drive,
    Mia::AIState ai_state = Mia::AIState::Listening,
    float brightness = 0.0f,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *service_status = nullptr,
    const std::vector<uint8_t> *obd_data = nullptr,
    uint64_t timestamp = 0) {
  auto service_status__ = service_status ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*service_status) : 0;
  auto obd_data__ = obd_data ? _fbb.CreateVector<uint8_t>(*obd_data) : 0;
  return Mia::CreateLEDState(
      _fbb,
      mode,
      ai_state,
      brightness,
      service_status__,
      obd_data__,
      timestamp);
}

struct VehicleTelemetry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VehicleTelemetryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RPM = 4,
    VT_SPEED_KMH = 6,
    VT_COOLANT_TEMP_C = 8,
    VT_OIL_TEMPERATURE_C = 10,
    VT_BATTERY_VOLTAGE = 12,
    VT_DPF_SOOT_LOAD_PERCENT = 14,
    VT_DPF_SOOT_MASS_G = 16,
    VT_DPF_REGENERATION_STATUS = 18,
    VT_EOLYS_ADDITIVE_LEVEL_PERCENT = 20,
    VT_EOLYS_ADDITIVE_LEVEL_L = 22,
    VT_INTAKE_AIR_TEMP_C = 24,
    VT_FUEL_LEVEL_PERCENT = 26,
    VT_ENGINE_LOAD_PERCENT = 28,
    VT_TIMESTAMP = 30
  };
  float rpm() const {
    return GetField<float>(VT_RPM, 0.0f);
  }
  bool mutate_rpm(float _rpm = 0.0f) {
    return SetField<float>(VT_RPM, _rpm, 0.0f);
  }
  float speed_kmh() const {
    return GetField<float>(VT_SPEED_KMH, 0.0f);
  }
  bool mutate_speed_kmh(float _speed_kmh = 0.0f) {
    return SetField<float>(VT_SPEED_KMH, _speed_kmh, 0.0f);
  }
  float coolant_temp_c() const {
    return GetField<float>(VT_COOLANT_TEMP_C, 0.0f);
  }
  bool mutate_coolant_temp_c(float _coolant_temp_c = 0.0f) {
    return SetField<float>(VT_COOLANT_TEMP_C, _coolant_temp_c, 0.0f);
  }
  float oil_temperature_c() const {
    return GetField<float>(VT_OIL_TEMPERATURE_C, 0.0f);
  }
  bool mutate_oil_temperature_c(float _oil_temperature_c = 0.0f) {
    return SetField<float>(VT_OIL_TEMPERATURE_C, _oil_temperature_c, 0.0f);
  }
  float battery_voltage() const {
    return GetField<float>(VT_BATTERY_VOLTAGE, 0.0f);
  }
  bool mutate_battery_voltage(float _battery_voltage = 0.0f) {
    return SetField<float>(VT_BATTERY_VOLTAGE, _battery_voltage, 0.0f);
  }
  float dpf_soot_load_percent() const {
    return GetField<float>(VT_DPF_SOOT_LOAD_PERCENT, 0.0f);
  }
  bool mutate_dpf_soot_load_percent(float _dpf_soot_load_percent = 0.0f) {
    return SetField<float>(VT_DPF_SOOT_LOAD_PERCENT, _dpf_soot_load_percent, 0.0f);
  }
  float dpf_soot_mass_g() const {
    return GetField<float>(VT_DPF_SOOT_MASS_G, 0.0f);
  }
  bool mutate_dpf_soot_mass_g(float _dpf_soot_mass_g = 0.0f) {
    return SetField<float>(VT_DPF_SOOT_MASS_G, _dpf_soot_mass_g, 0.0f);
  }
  Mia::DpfStatus dpf_regeneration_status() const {
    return static_cast<Mia::DpfStatus>(GetField<int8_t>(VT_DPF_REGENERATION_STATUS, 0));
  }
  bool mutate_dpf_regeneration_status(Mia::DpfStatus _dpf_regeneration_status = static_cast<Mia::DpfStatus>(0)) {
    return SetField<int8_t>(VT_DPF_REGENERATION_STATUS, static_cast<int8_t>(_dpf_regeneration_status), 0);
  }
  float eolys_additive_level_percent() const {
    return GetField<float>(VT_EOLYS_ADDITIVE_LEVEL_PERCENT, 0.0f);
  }
  bool mutate_eolys_additive_level_percent(float _eolys_additive_level_percent = 0.0f) {
    return SetField<float>(VT_EOLYS_ADDITIVE_LEVEL_PERCENT, _eolys_additive_level_percent, 0.0f);
  }
  float eolys_additive_level_l() const {
    return GetField<float>(VT_EOLYS_ADDITIVE_LEVEL_L, 0.0f);
  }
  bool mutate_eolys_additive_level_l(float _eolys_additive_level_l = 0.0f) {
    return SetField<float>(VT_EOLYS_ADDITIVE_LEVEL_L, _eolys_additive_level_l, 0.0f);
  }
  float intake_air_temp_c() const {
    return GetField<float>(VT_INTAKE_AIR_TEMP_C, 0.0f);
  }
  bool mutate_intake_air_temp_c(float _intake_air_temp_c = 0.0f) {
    return SetField<float>(VT_INTAKE_AIR_TEMP_C, _intake_air_temp_c, 0.0f);
  }
  float fuel_level_percent() const {
    return GetField<float>(VT_FUEL_LEVEL_PERCENT, 0.0f);
  }
  bool mutate_fuel_level_percent(float _fuel_level_percent = 0.0f) {
    return SetField<float>(VT_FUEL_LEVEL_PERCENT, _fuel_level_percent, 0.0f);
  }
  float engine_load_percent() const {
    return GetField<float>(VT_ENGINE_LOAD_PERCENT, 0.0f);
  }
  bool mutate_engine_load_percent(float _engine_load_percent = 0.0f) {
    return SetField<float>(VT_ENGINE_LOAD_PERCENT, _engine_load_percent, 0.0f);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(uint64_t _timestamp = 0) {
    return SetField<uint64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RPM, 4) &&
           VerifyField<float>(verifier, VT_SPEED_KMH, 4) &&
           VerifyField<float>(verifier, VT_COOLANT_TEMP_C, 4) &&
           VerifyField<float>(verifier, VT_OIL_TEMPERATURE_C, 4) &&
           VerifyField<float>(verifier, VT_BATTERY_VOLTAGE, 4) &&
           VerifyField<float>(verifier, VT_DPF_SOOT_LOAD_PERCENT, 4) &&
           VerifyField<float>(verifier, VT_DPF_SOOT_MASS_G, 4) &&
           VerifyField<int8_t>(verifier, VT_DPF_REGENERATION_STATUS, 1) &&
           VerifyField<float>(verifier, VT_EOLYS_ADDITIVE_LEVEL_PERCENT, 4) &&
           VerifyField<float>(verifier, VT_EOLYS_ADDITIVE_LEVEL_L, 4) &&
           VerifyField<float>(verifier, VT_INTAKE_AIR_TEMP_C, 4) &&
           VerifyField<float>(verifier, VT_FUEL_LEVEL_PERCENT, 4) &&
           VerifyField<float>(verifier, VT_ENGINE_LOAD_PERCENT, 4) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct VehicleTelemetryBuilder {
  typedef VehicleTelemetry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rpm(float rpm) {
    fbb_.AddElement<float>(VehicleTelemetry::VT_RPM, rpm, 0.0f);
  }
  void add_speed_kmh(float speed_kmh) {
    fbb_.AddElement<float>(VehicleTelemetry::VT_SPEED_KMH, speed_kmh, 0.0f);
  }
  void add_coolant_temp_c(float coolant_temp_c) {
    fbb_.AddElement<float>(VehicleTelemetry::VT_COOLANT_TEMP_C, coolant_temp_c, 0.0f);
  }
  void add_oil_temperature_c(float oil_temperature_c) {
    fbb_.AddElement<float>(VehicleTelemetry::VT_OIL_TEMPERATURE_C, oil_temperature_c, 0.0f);
  }
  void add_battery_voltage(float battery_voltage) {
    fbb_.AddElement<float>(VehicleTelemetry::VT_BATTERY_VOLTAGE, battery_voltage, 0.0f);
  }
  void add_dpf_soot_load_percent(float dpf_soot_load_percent) {
    fbb_.AddElement<float>(VehicleTelemetry::VT_DPF_SOOT_LOAD_PERCENT, dpf_soot_load_percent, 0.0f);
  }
  void add_dpf_soot_mass_g(float dpf_soot_mass_g) {
    fbb_.AddElement<float>(VehicleTelemetry::VT_DPF_SOOT_MASS_G, dpf_soot_mass_g, 0.0f);
  }
  void add_dpf_regeneration_status(Mia::DpfStatus dpf_regeneration_status) {
    fbb_.AddElement<int8_t>(VehicleTelemetry::VT_DPF_REGENERATION_STATUS, static_cast<int8_t>(dpf_regeneration_status), 0);
  }
  void add_eolys_additive_level_percent(float eolys_additive_level_percent) {
    fbb_.AddElement<float>(VehicleTelemetry::VT_EOLYS_ADDITIVE_LEVEL_PERCENT, eolys_additive_level_percent, 0.0f);
  }
  void add_eolys_additive_level_l(float eolys_additive_level_l) {
    fbb_.AddElement<float>(VehicleTelemetry::VT_EOLYS_ADDITIVE_LEVEL_L, eolys_additive_level_l, 0.0f);
  }
  void add_intake_air_temp_c(float intake_air_temp_c) {
    fbb_.AddElement<float>(VehicleTelemetry::VT_INTAKE_AIR_TEMP_C, intake_air_temp_c, 0.0f);
  }
  void add_fuel_level_percent(float fuel_level_percent) {
    fbb_.AddElement<float>(VehicleTelemetry::VT_FUEL_LEVEL_PERCENT, fuel_level_percent, 0.0f);
  }
  void add_engine_load_percent(float engine_load_percent) {
    fbb_.AddElement<float>(VehicleTelemetry::VT_ENGINE_LOAD_PERCENT, engine_load_percent, 0.0f);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(VehicleTelemetry::VT_TIMESTAMP, timestamp, 0);
  }
  explicit VehicleTelemetryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VehicleTelemetry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VehicleTelemetry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VehicleTelemetry> CreateVehicleTelemetry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float rpm = 0.0f,
    float speed_kmh = 0.0f,
    float coolant_temp_c = 0.0f,
    float oil_temperature_c = 0.0f,
    float battery_voltage = 0.0f,
    float dpf_soot_load_percent = 0.0f,
    float dpf_soot_mass_g = 0.0f,
    Mia::DpfStatus dpf_regeneration_status = Mia::DpfStatus::Normal,
    float eolys_additive_level_percent = 0.0f,
    float eolys_additive_level_l = 0.0f,
    float intake_air_temp_c = 0.0f,
    float fuel_level_percent = 0.0f,
    float engine_load_percent = 0.0f,
    uint64_t timestamp = 0) {
  VehicleTelemetryBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_engine_load_percent(engine_load_percent);
  builder_.add_fuel_level_percent(fuel_level_percent);
  builder_.add_intake_air_temp_c(intake_air_temp_c);
  builder_.add_eolys_additive_level_l(eolys_additive_level_l);
  builder_.add_eolys_additive_level_percent(eolys_additive_level_percent);
  builder_.add_dpf_soot_mass_g(dpf_soot_mass_g);
  builder_.add_dpf_soot_load_percent(dpf_soot_load_percent);
  builder_.add_battery_voltage(battery_voltage);
  builder_.add_oil_temperature_c(oil_temperature_c);
  builder_.add_coolant_temp_c(coolant_temp_c);
  builder_.add_speed_kmh(speed_kmh);
  builder_.add_rpm(rpm);
  builder_.add_dpf_regeneration_status(dpf_regeneration_status);
  return builder_.Finish();
}

inline const Mia::VehicleTelemetry *GetVehicleTelemetry(const void *buf) {
  return ::flatbuffers::GetRoot<Mia::VehicleTelemetry>(buf);
}

inline const Mia::VehicleTelemetry *GetSizePrefixedVehicleTelemetry(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Mia::VehicleTelemetry>(buf);
}

inline VehicleTelemetry *GetMutableVehicleTelemetry(void *buf) {
  return ::flatbuffers::GetMutableRoot<VehicleTelemetry>(buf);
}

inline Mia::VehicleTelemetry *GetMutableSizePrefixedVehicleTelemetry(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<Mia::VehicleTelemetry>(buf);
}

inline bool VerifyVehicleTelemetryBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Mia::VehicleTelemetry>(nullptr);
}

inline bool VerifySizePrefixedVehicleTelemetryBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Mia::VehicleTelemetry>(nullptr);
}

inline void FinishVehicleTelemetryBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Mia::VehicleTelemetry> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedVehicleTelemetryBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Mia::VehicleTelemetry> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Mia

#endif  // FLATBUFFERS_GENERATED_MIA_MIA_H_
