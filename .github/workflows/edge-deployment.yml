name: Edge Deployment Pipeline

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      target_device:
        description: 'Target edge device'
        required: true
        default: 'raspberry-pi'
        type: choice
        options:
        - raspberry-pi
        - automotive-hardware
        - edge-gateway
        - all-devices
      deployment_type:
        description: 'Deployment type'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
        - development

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # =============================================================================
  # RASPBERRY PI DEPLOYMENT
  # =============================================================================
  deploy-raspberry-pi:
    name: Deploy to Raspberry Pi
    runs-on: ubuntu-latest
    if: ${{ inputs.target_device == 'raspberry-pi' || inputs.target_device == 'all-devices' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install deployment tools
      run: |
        pip install ansible paramiko
        sudo apt-get update
        sudo apt-get install -y ansible
    
    - name: Create Raspberry Pi deployment configuration
      run: |
        cat > raspberry-pi-deploy.yml << 'EOF'
        ---
        - name: Deploy AI-SERVIS to Raspberry Pi
          hosts: raspberry_pi
          become: yes
          vars:
            deployment_type: ${{ inputs.deployment_type }}
            registry: ${{ env.REGISTRY }}
            image_name: ${{ env.IMAGE_NAME }}
            version: ${{ github.ref_name }}
          
          tasks:
            - name: Update system packages
              apt:
                update_cache: yes
                upgrade: yes
            
            - name: Install Docker
              apt:
                name: docker.io
                state: present
            
            - name: Install Docker Compose
              pip:
                name: docker-compose
                state: present
            
            - name: Start Docker service
              systemd:
                name: docker
                state: started
                enabled: yes
            
            - name: Create AI-SERVIS directory
              file:
                path: /opt/ai-servis
                state: directory
                mode: '0755'
            
            - name: Copy deployment files
              copy:
                src: "{{ item }}"
                dest: /opt/ai-servis/
              loop:
                - docker-compose.yml
                - docker-compose.pi-simulation.yml
                - orchestrator-config.yaml
            
            - name: Create systemd service
              template:
                src: ai-servis.service.j2
                dest: /etc/systemd/system/ai-servis.service
                mode: '0644'
            
            - name: Reload systemd
              systemd:
                daemon_reload: yes
            
            - name: Start AI-SERVIS service
              systemd:
                name: ai-servis
                state: started
                enabled: yes
            
            - name: Wait for services to be ready
              wait_for:
                port: 8080
                host: localhost
                delay: 10
                timeout: 60
            
            - name: Run health check
              uri:
                url: http://localhost:8080/health
                method: GET
                status_code: 200
        EOF
        
        cat > ai-servis.service.j2 << 'EOF'
        [Unit]
        Description=AI-SERVIS Universal Platform
        After=docker.service
        Requires=docker.service
        
        [Service]
        Type=oneshot
        RemainAfterExit=yes
        WorkingDirectory=/opt/ai-servis
        ExecStart=/usr/local/bin/docker-compose up -d
        ExecStop=/usr/local/bin/docker-compose down
        TimeoutStartSec=0
        
        [Install]
        WantedBy=multi-user.target
        EOF
    
    - name: Create Raspberry Pi inventory
      run: |
        cat > raspberry-pi-inventory.ini << 'EOF'
        [raspberry_pi]
        pi-device ansible_host=${{ secrets.RASPBERRY_PI_HOST }} ansible_user=${{ secrets.RASPBERRY_PI_USER }} ansible_ssh_private_key_file=${{ secrets.RASPBERRY_PI_SSH_KEY }}
        EOF
    
    - name: Deploy to Raspberry Pi
      run: |
        ansible-playbook -i raspberry-pi-inventory.ini raspberry-pi-deploy.yml \
          --extra-vars "deployment_type=${{ inputs.deployment_type }}"
    
    - name: Test Raspberry Pi deployment
      run: |
        # Test basic connectivity
        curl -f http://${{ secrets.RASPBERRY_PI_HOST }}:8080/health || exit 1
        
        # Test GPIO simulation
        curl -f http://${{ secrets.RASPBERRY_PI_HOST }}:5555/health || exit 1
        
        echo "Raspberry Pi deployment test successful"

  # =============================================================================
  # AUTOMOTIVE HARDWARE DEPLOYMENT
  # =============================================================================
  deploy-automotive-hardware:
    name: Deploy to Automotive Hardware
    runs-on: ubuntu-latest
    if: ${{ inputs.target_device == 'automotive-hardware' || inputs.target_device == 'all-devices' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install automotive deployment tools
      run: |
        pip install ansible paramiko can-utils
        sudo apt-get update
        sudo apt-get install -y ansible can-utils
    
    - name: Create automotive hardware deployment configuration
      run: |
        cat > automotive-deploy.yml << 'EOF'
        ---
        - name: Deploy AI-SERVIS to Automotive Hardware
          hosts: automotive_hardware
          become: yes
          vars:
            deployment_type: ${{ inputs.deployment_type }}
            registry: ${{ env.REGISTRY }}
            image_name: ${{ env.IMAGE_NAME }}
            version: ${{ github.ref_name }}
          
          tasks:
            - name: Update system packages
              apt:
                update_cache: yes
                upgrade: yes
            
            - name: Install automotive dependencies
              apt:
                name:
                  - can-utils
                  - python3-can
                  - python3-serial
                  - python3-rpi.gpio
                state: present
            
            - name: Install Docker
              apt:
                name: docker.io
                state: present
            
            - name: Start Docker service
              systemd:
                name: docker
                state: started
                enabled: yes
            
            - name: Create AI-SERVIS directory
              file:
                path: /opt/ai-servis
                state: directory
                mode: '0755'
            
            - name: Copy automotive configuration
              copy:
                src: "{{ item }}"
                dest: /opt/ai-servis/
              loop:
                - docker-compose.yml
                - docker-compose.pi-simulation.yml
                - orchestrator-config.yaml
                - automotive-config.yaml
            
            - name: Configure CAN interface
              template:
                src: can-config.j2
                dest: /etc/systemd/network/can0.network
                mode: '0644'
            
            - name: Configure GPIO permissions
              lineinfile:
                path: /etc/udev/rules.d/99-gpio.rules
                line: 'SUBSYSTEM=="gpio", GROUP="gpio", MODE="0664"'
                create: yes
            
            - name: Create automotive systemd service
              template:
                src: ai-servis-automotive.service.j2
                dest: /etc/systemd/system/ai-servis-automotive.service
                mode: '0644'
            
            - name: Reload systemd
              systemd:
                daemon_reload: yes
            
            - name: Start AI-SERVIS automotive service
              systemd:
                name: ai-servis-automotive
                state: started
                enabled: yes
            
            - name: Wait for automotive services
              wait_for:
                port: 8080
                host: localhost
                delay: 15
                timeout: 90
            
            - name: Test OBD-II connection
              command: python3 -c "
              import can
              bus = can.interface.Bus('can0', bustype='socketcan')
              print('OBD-II connection successful')
              bus.shutdown()
              "
            
            - name: Test GPIO access
              command: python3 -c "
              import RPi.GPIO as GPIO
              GPIO.setmode(GPIO.BCM)
              print('GPIO access successful')
              "
        EOF
        
        cat > can-config.j2 << 'EOF'
        [Match]
        Name=can0
        
        [Network]
        CAN=yes
        EOF
        
        cat > ai-servis-automotive.service.j2 << 'EOF'
        [Unit]
        Description=AI-SERVIS Automotive Platform
        After=docker.service
        Requires=docker.service
        
        [Service]
        Type=oneshot
        RemainAfterExit=yes
        WorkingDirectory=/opt/ai-servis
        ExecStart=/usr/local/bin/docker-compose -f docker-compose.pi-simulation.yml up -d
        ExecStop=/usr/local/bin/docker-compose -f docker-compose.pi-simulation.yml down
        TimeoutStartSec=0
        
        [Install]
        WantedBy=multi-user.target
        EOF
    
    - name: Create automotive hardware inventory
      run: |
        cat > automotive-inventory.ini << 'EOF'
        [automotive_hardware]
        automotive-device ansible_host=${{ secrets.AUTOMOTIVE_HOST }} ansible_user=${{ secrets.AUTOMOTIVE_USER }} ansible_ssh_private_key_file=${{ secrets.AUTOMOTIVE_SSH_KEY }}
        EOF
    
    - name: Deploy to automotive hardware
      run: |
        ansible-playbook -i automotive-inventory.ini automotive-deploy.yml \
          --extra-vars "deployment_type=${{ inputs.deployment_type }}"
    
    - name: Test automotive hardware deployment
      run: |
        # Test OBD-II connectivity
        curl -f http://${{ secrets.AUTOMOTIVE_HOST }}:8080/health || exit 1
        
        # Test CAN bus communication
        curl -f http://${{ secrets.AUTOMOTIVE_HOST }}:5555/health || exit 1
        
        echo "Automotive hardware deployment test successful"

  # =============================================================================
  # EDGE GATEWAY DEPLOYMENT
  # =============================================================================
  deploy-edge-gateway:
    name: Deploy to Edge Gateway
    runs-on: ubuntu-latest
    if: ${{ inputs.target_device == 'edge-gateway' || inputs.target_device == 'all-devices' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install edge gateway deployment tools
      run: |
        pip install ansible paramiko kubernetes
        sudo apt-get update
        sudo apt-get install -y ansible kubectl
    
    - name: Create edge gateway deployment configuration
      run: |
        cat > edge-gateway-deploy.yml << 'EOF'
        ---
        - name: Deploy AI-SERVIS to Edge Gateway
          hosts: edge_gateway
          become: yes
          vars:
            deployment_type: ${{ inputs.deployment_type }}
            registry: ${{ env.REGISTRY }}
            image_name: ${{ env.IMAGE_NAME }}
            version: ${{ github.ref_name }}
          
          tasks:
            - name: Update system packages
              apt:
                update_cache: yes
                upgrade: yes
            
            - name: Install Kubernetes
              apt:
                name:
                  - kubelet
                  - kubeadm
                  - kubectl
                state: present
            
            - name: Install Docker
              apt:
                name: docker.io
                state: present
            
            - name: Start Docker service
              systemd:
                name: docker
                state: started
                enabled: yes
            
            - name: Initialize Kubernetes cluster
              command: kubeadm init --pod-network-cidr=10.244.0.0/16
              when: deployment_type == 'production'
            
            - name: Create AI-SERVIS namespace
              kubernetes.core.k8s:
                name: ai-servis
                api_version: v1
                kind: Namespace
                state: present
            
            - name: Deploy AI-SERVIS to Kubernetes
              kubernetes.core.k8s:
                definition: "{{ lookup('template', 'ai-servis-deployment.yaml.j2') }}"
                state: present
                namespace: ai-servis
            
            - name: Wait for deployment to be ready
              kubernetes.core.k8s_info:
                api_version: apps/v1
                kind: Deployment
                name: ai-servis-core
                namespace: ai-servis
                wait: true
                wait_condition:
                  type: Available
                  status: "True"
                wait_timeout: 300
        EOF
        
        cat > ai-servis-deployment.yaml.j2 << 'EOF'
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: ai-servis-core
          namespace: ai-servis
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: ai-servis-core
          template:
            metadata:
              labels:
                app: ai-servis-core
            spec:
              containers:
              - name: core-orchestrator
                image: {{ registry }}/{{ image_name }}/core-orchestrator:{{ version }}
                ports:
                - containerPort: 8080
                env:
                - name: MCP_MODE
                  value: "orchestrator"
                - name: LOG_LEVEL
                  value: "INFO"
              - name: ai-audio-assistant
                image: {{ registry }}/{{ image_name }}/ai-audio-assistant:{{ version }}
                ports:
                - containerPort: 8081
                env:
                - name: MCP_MODE
                  value: "server"
                - name: AUDIO_QUALITY
                  value: "high"
              - name: hardware-bridge
                image: {{ registry }}/{{ image_name }}/hardware-bridge:{{ version }}
                ports:
                - containerPort: 5555
                env:
                - name: MQTT_BROKER
                  value: "mosquitto"
                - name: GPIO_MODE
                  value: "simulation"
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: ai-servis-service
          namespace: ai-servis
        spec:
          selector:
            app: ai-servis-core
          ports:
          - name: orchestrator
            port: 8080
            targetPort: 8080
          - name: audio
            port: 8081
            targetPort: 8081
          - name: hardware
            port: 5555
            targetPort: 5555
          type: LoadBalancer
        EOF
    
    - name: Create edge gateway inventory
      run: |
        cat > edge-gateway-inventory.ini << 'EOF'
        [edge_gateway]
        edge-device ansible_host=${{ secrets.EDGE_GATEWAY_HOST }} ansible_user=${{ secrets.EDGE_GATEWAY_USER }} ansible_ssh_private_key_file=${{ secrets.EDGE_GATEWAY_SSH_KEY }}
        EOF
    
    - name: Deploy to edge gateway
      run: |
        ansible-playbook -i edge-gateway-inventory.ini edge-gateway-deploy.yml \
          --extra-vars "deployment_type=${{ inputs.deployment_type }}"
    
    - name: Test edge gateway deployment
      run: |
        # Test Kubernetes deployment
        kubectl get pods -n ai-servis || exit 1
        
        # Test service connectivity
        curl -f http://${{ secrets.EDGE_GATEWAY_HOST }}:8080/health || exit 1
        
        echo "Edge gateway deployment test successful"

  # =============================================================================
  # DEPLOYMENT VERIFICATION
  # =============================================================================
  verify-deployment:
    name: Verify Edge Deployment
    runs-on: ubuntu-latest
    needs: [deploy-raspberry-pi, deploy-automotive-hardware, deploy-edge-gateway]
    if: always()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install verification tools
      run: |
        pip install requests pytest
    
    - name: Run deployment verification tests
      run: |
        python << 'EOF'
        import requests
        import json
        from datetime import datetime
        
        # Test endpoints for different devices
        test_endpoints = []
        
        if "${{ inputs.target_device }}" in ["raspberry-pi", "all-devices"]:
            test_endpoints.extend([
                {"name": "Raspberry Pi Core", "url": "http://${{ secrets.RASPBERRY_PI_HOST }}:8080/health"},
                {"name": "Raspberry Pi Hardware", "url": "http://${{ secrets.RASPBERRY_PI_HOST }}:5555/health"}
            ])
        
        if "${{ inputs.target_device }}" in ["automotive-hardware", "all-devices"]:
            test_endpoints.extend([
                {"name": "Automotive Core", "url": "http://${{ secrets.AUTOMOTIVE_HOST }}:8080/health"},
                {"name": "Automotive Hardware", "url": "http://${{ secrets.AUTOMOTIVE_HOST }}:5555/health"}
            ])
        
        if "${{ inputs.target_device }}" in ["edge-gateway", "all-devices"]:
            test_endpoints.extend([
                {"name": "Edge Gateway Core", "url": "http://${{ secrets.EDGE_GATEWAY_HOST }}:8080/health"},
                {"name": "Edge Gateway Audio", "url": "http://${{ secrets.EDGE_GATEWAY_HOST }}:8081/health"}
            ])
        
        # Run verification tests
        results = {
            "timestamp": datetime.now().isoformat(),
            "deployment_type": "${{ inputs.deployment_type }}",
            "target_device": "${{ inputs.target_device }}",
            "tests": []
        }
        
        for endpoint in test_endpoints:
            try:
                response = requests.get(endpoint["url"], timeout=10)
                result = {
                    "name": endpoint["name"],
                    "url": endpoint["url"],
                    "status_code": response.status_code,
                    "success": response.status_code == 200,
                    "response_time": response.elapsed.total_seconds()
                }
            except Exception as e:
                result = {
                    "name": endpoint["name"],
                    "url": endpoint["url"],
                    "error": str(e),
                    "success": False
                }
            
            results["tests"].append(result)
        
        # Calculate summary
        total_tests = len(results["tests"])
        successful_tests = sum(1 for test in results["tests"] if test["success"])
        results["summary"] = {
            "total_tests": total_tests,
            "successful_tests": successful_tests,
            "success_rate": (successful_tests / total_tests) * 100 if total_tests > 0 else 0
        }
        
        # Save results
        with open("deployment-verification-results.json", "w") as f:
            json.dump(results, f, indent=2)
        
        print(f"Deployment verification completed: {successful_tests}/{total_tests} tests passed")
        
        # Exit with error if any tests failed
        if successful_tests < total_tests:
            print("Some deployment verification tests failed")
            exit(1)
        EOF
    
    - name: Upload verification results
      uses: actions/upload-artifact@v3
      with:
        name: deployment-verification
        path: deployment-verification-results.json

  # =============================================================================
  # DEPLOYMENT NOTIFICATION
  # =============================================================================
  notify-deployment:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [verify-deployment]
    if: always()
    
    steps:
    - name: Download verification results
      uses: actions/download-artifact@v3
      with:
        path: ./verification-results
    
    - name: Generate deployment report
      run: |
        python << 'EOF'
        import json
        import os
        
        # Load verification results
        with open("verification-results/deployment-verification-results.json") as f:
            results = json.load(f)
        
        # Generate deployment report
        report = {
            "timestamp": results["timestamp"],
            "repository": os.environ.get("GITHUB_REPOSITORY", "unknown"),
            "deployment_type": results["deployment_type"],
            "target_device": results["target_device"],
            "summary": results["summary"],
            "status": "success" if results["summary"]["success_rate"] == 100 else "partial" if results["summary"]["success_rate"] > 0 else "failed"
        }
        
        with open("deployment-report.json", "w") as f:
            json.dump(report, f, indent=2)
        
        print(f"Deployment report generated: {report['status']}")
        EOF
    
    - name: Notify deployment status
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#edge-deployments'
        webhook_url: ${{ secrets.EDGE_DEPLOYMENT_SLACK_WEBHOOK }}
        custom_payload: |
          {
            "text": "ðŸš€ Edge Deployment Complete",
            "attachments": [{
              "color": "${{ job.status == 'success' && 'good' || 'danger' }}",
              "fields": [{
                "title": "Repository",
                "value": "${{ github.repository }}",
                "short": true
              }, {
                "title": "Target Device",
                "value": "${{ inputs.target_device }}",
                "short": true
              }, {
                "title": "Deployment Type",
                "value": "${{ inputs.deployment_type }}",
                "short": true
              }, {
                "title": "Status",
                "value": "${{ job.status }}",
                "short": true
              }]
            }]
          }
    
    - name: Upload deployment report
      uses: actions/upload-artifact@v3
      with:
        name: deployment-report
        path: deployment-report.json